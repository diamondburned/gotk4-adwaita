// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"runtime"
	"unsafe"

	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #cgo pkg-config: libadwaita-1
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <adwaita.h>
// #include <glib-object.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.adw_combo_row_get_type()), F: marshalComboRower},
	})
}

// ComboRow: gtk.ListBoxRow used to choose from a list of items.
//
// The AdwComboRow widget allows the user to choose from a list of valid
// choices. The row displays the selected choice. When activated, the row
// displays a popover which allows the user to make a new choice.
//
// AdwComboRow mirrors gtk.DropDown, see that widget for details.
//
// AdwComboRow is gtk.ListBoxRow:activatable if a model is set.
//
//
// CSS nodes
//
// AdwComboRow has a main CSS node with name row and the .combo style class.
//
// Its popover has the node named popover with the .combo style class, it
// contains a gtk.ScrolledWindow, which in turn contains a gtk.ListView, both
// are accessible via their regular nodes.
//
//
// Accessibility
//
// AdwComboRow uses the GTK_ACCESSIBLE_ROLE_COMBO_BOX role.
type ComboRow struct {
	ActionRow
}

func wrapComboRow(obj *externglib.Object) *ComboRow {
	return &ComboRow{
		ActionRow: ActionRow{
			PreferencesRow: PreferencesRow{
				ListBoxRow: gtk.ListBoxRow{
					Widget: gtk.Widget{
						InitiallyUnowned: externglib.InitiallyUnowned{
							Object: obj,
						},
						Accessible: gtk.Accessible{
							Object: obj,
						},
						Buildable: gtk.Buildable{
							Object: obj,
						},
						ConstraintTarget: gtk.ConstraintTarget{
							Object: obj,
						},
						Object: obj,
					},
					Actionable: gtk.Actionable{
						Widget: gtk.Widget{
							InitiallyUnowned: externglib.InitiallyUnowned{
								Object: obj,
							},
							Accessible: gtk.Accessible{
								Object: obj,
							},
							Buildable: gtk.Buildable{
								Object: obj,
							},
							ConstraintTarget: gtk.ConstraintTarget{
								Object: obj,
							},
							Object: obj,
						},
					},
					Object: obj,
				},
			},
		},
	}
}

func marshalComboRower(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapComboRow(obj), nil
}

// NewComboRow creates a new AdwComboRow.
func NewComboRow() *ComboRow {
	var _cret *C.GtkWidget // in

	_cret = C.adw_combo_row_new()

	var _comboRow *ComboRow // out

	_comboRow = wrapComboRow(externglib.Take(unsafe.Pointer(_cret)))

	return _comboRow
}

// Expression gets the expression used to obtain strings from items.
func (self *ComboRow) Expression() gtk.Expressioner {
	var _arg0 *C.AdwComboRow   // out
	var _cret *C.GtkExpression // in

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))

	_cret = C.adw_combo_row_get_expression(_arg0)
	runtime.KeepAlive(self)

	var _expression gtk.Expressioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(gtk.Expressioner)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gtk.Expressioner")
			}
			_expression = rv
		}
	}

	return _expression
}

// Factory gets the factory that's currently used to populate list items.
func (self *ComboRow) Factory() *gtk.ListItemFactory {
	var _arg0 *C.AdwComboRow        // out
	var _cret *C.GtkListItemFactory // in

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))

	_cret = C.adw_combo_row_get_factory(_arg0)
	runtime.KeepAlive(self)

	var _listItemFactory *gtk.ListItemFactory // out

	if _cret != nil {
		{
			obj := externglib.Take(unsafe.Pointer(_cret))
			_listItemFactory = &gtk.ListItemFactory{
				Object: obj,
			}
		}
	}

	return _listItemFactory
}

// ListFactory gets the factory that's currently used to populate list items in
// the popup.
func (self *ComboRow) ListFactory() *gtk.ListItemFactory {
	var _arg0 *C.AdwComboRow        // out
	var _cret *C.GtkListItemFactory // in

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))

	_cret = C.adw_combo_row_get_list_factory(_arg0)
	runtime.KeepAlive(self)

	var _listItemFactory *gtk.ListItemFactory // out

	if _cret != nil {
		{
			obj := externglib.Take(unsafe.Pointer(_cret))
			_listItemFactory = &gtk.ListItemFactory{
				Object: obj,
			}
		}
	}

	return _listItemFactory
}

// Model gets the model that provides the displayed items.
func (self *ComboRow) Model() gio.ListModeller {
	var _arg0 *C.AdwComboRow // out
	var _cret *C.GListModel  // in

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))

	_cret = C.adw_combo_row_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel gio.ListModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := externglib.Take(objptr)
			rv, ok := (externglib.CastObject(object)).(gio.ListModeller)
			if !ok {
				panic("object of type " + object.TypeFromInstance().String() + " is not gio.ListModeller")
			}
			_listModel = rv
		}
	}

	return _listModel
}

// Selected gets the position of the selected item.
func (self *ComboRow) Selected() uint {
	var _arg0 *C.AdwComboRow // out
	var _cret C.guint        // in

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))

	_cret = C.adw_combo_row_get_selected(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SelectedItem gets the selected item.
func (self *ComboRow) SelectedItem() *externglib.Object {
	var _arg0 *C.AdwComboRow // out
	var _cret C.gpointer     // in

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))

	_cret = C.adw_combo_row_get_selected_item(_arg0)
	runtime.KeepAlive(self)

	var _object *externglib.Object // out

	_object = externglib.Take(unsafe.Pointer(_cret))

	return _object
}

// UseSubtitle gets whether to use the current value as the subtitle.
func (self *ComboRow) UseSubtitle() bool {
	var _arg0 *C.AdwComboRow // out
	var _cret C.gboolean     // in

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))

	_cret = C.adw_combo_row_get_use_subtitle(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetExpression sets the expression used to obtain strings from items.
//
// The expression must have a value type of G_TYPE_STRING.
func (self *ComboRow) SetExpression(expression gtk.Expressioner) {
	var _arg0 *C.AdwComboRow   // out
	var _arg1 *C.GtkExpression // out

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))
	if expression != nil {
		_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))
	}

	C.adw_combo_row_set_expression(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(expression)
}

// SetFactory sets the GtkListItemFactory to use for populating list items.
func (self *ComboRow) SetFactory(factory *gtk.ListItemFactory) {
	var _arg0 *C.AdwComboRow        // out
	var _arg1 *C.GtkListItemFactory // out

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))
	if factory != nil {
		_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))
	}

	C.adw_combo_row_set_factory(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(factory)
}

// SetListFactory sets the GtkListItemFactory to use for populating list items
// in the popup.
func (self *ComboRow) SetListFactory(factory *gtk.ListItemFactory) {
	var _arg0 *C.AdwComboRow        // out
	var _arg1 *C.GtkListItemFactory // out

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))
	if factory != nil {
		_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))
	}

	C.adw_combo_row_set_list_factory(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(factory)
}

// SetModel sets the gio.ListModel to use.
func (self *ComboRow) SetModel(model gio.ListModeller) {
	var _arg0 *C.AdwComboRow // out
	var _arg1 *C.GListModel  // out

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
	}

	C.adw_combo_row_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetSelected selects the item at the given position.
func (self *ComboRow) SetSelected(position uint) {
	var _arg0 *C.AdwComboRow // out
	var _arg1 C.guint        // out

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))
	_arg1 = C.guint(position)

	C.adw_combo_row_set_selected(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
}

// SetUseSubtitle sets whether to use the current value as the subtitle.
func (self *ComboRow) SetUseSubtitle(useSubtitle bool) {
	var _arg0 *C.AdwComboRow // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.AdwComboRow)(unsafe.Pointer(self.Native()))
	if useSubtitle {
		_arg1 = C.TRUE
	}

	C.adw_combo_row_set_use_subtitle(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(useSubtitle)
}
