// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <adwaita.h>
// #include <glib-object.h>
// double _gotk4_adw1_Swipeable_virtual_get_cancel_progress(void* fnptr, AdwSwipeable* arg0) {
//   return ((double (*)(AdwSwipeable*))(fnptr))(arg0);
// };
// double _gotk4_adw1_Swipeable_virtual_get_distance(void* fnptr, AdwSwipeable* arg0) {
//   return ((double (*)(AdwSwipeable*))(fnptr))(arg0);
// };
// double _gotk4_adw1_Swipeable_virtual_get_progress(void* fnptr, AdwSwipeable* arg0) {
//   return ((double (*)(AdwSwipeable*))(fnptr))(arg0);
// };
// double* _gotk4_adw1_Swipeable_virtual_get_snap_points(void* fnptr, AdwSwipeable* arg0, int* arg1) {
//   return ((double* (*)(AdwSwipeable*, int*))(fnptr))(arg0, arg1);
// };
// void _gotk4_adw1_Swipeable_virtual_get_swipe_area(void* fnptr, AdwSwipeable* arg0, AdwNavigationDirection arg1, gboolean arg2, GdkRectangle* arg3) {
//   ((void (*)(AdwSwipeable*, AdwNavigationDirection, gboolean, GdkRectangle*))(fnptr))(arg0, arg1, arg2, arg3);
// };
import "C"

// GType values.
var (
	GTypeSwipeable = coreglib.Type(C.adw_swipeable_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeSwipeable, F: marshalSwipeable},
	})
}

// Swipeable: interface for swipeable widgets.
//
// The AdwSwipeable interface is implemented by all swipeable widgets.
//
// See swipetracker for details about implementing it.
//
// Swipeable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Swipeable struct {
	_ [0]func() // equal guard
	gtk.Widget
}

var (
	_ gtk.Widgetter = (*Swipeable)(nil)
)

// Swipeabler describes Swipeable's interface methods.
type Swipeabler interface {
	coreglib.Objector

	// CancelProgress gets the progress self will snap back to after the gesture
	// is canceled.
	CancelProgress() float64
	// Distance gets the swipe distance of self.
	Distance() float64
	// Progress gets the current progress of self.
	Progress() float64
	// SnapPoints gets the snap points of self.
	SnapPoints() []float64
	// SwipeArea gets the area self can start a swipe from for the given
	// direction and gesture type.
	SwipeArea(navigationDirection NavigationDirection, isDrag bool) *gdk.Rectangle
}

var _ Swipeabler = (*Swipeable)(nil)

func wrapSwipeable(obj *coreglib.Object) *Swipeable {
	return &Swipeable{
		Widget: gtk.Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: gtk.Accessible{
				Object: obj,
			},
			Buildable: gtk.Buildable{
				Object: obj,
			},
			ConstraintTarget: gtk.ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalSwipeable(p uintptr) (interface{}, error) {
	return wrapSwipeable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CancelProgress gets the progress self will snap back to after the gesture is
// canceled.
//
// The function returns the following values:
//
//   - gdouble: cancel progress, unitless.
//
func (self *Swipeable) CancelProgress() float64 {
	var _arg0 *C.AdwSwipeable // out
	var _cret C.double        // in

	_arg0 = (*C.AdwSwipeable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_swipeable_get_cancel_progress(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Distance gets the swipe distance of self.
//
// This corresponds to how many pixels 1 unit represents.
//
// The function returns the following values:
//
//   - gdouble: swipe distance in pixels.
//
func (self *Swipeable) Distance() float64 {
	var _arg0 *C.AdwSwipeable // out
	var _cret C.double        // in

	_arg0 = (*C.AdwSwipeable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_swipeable_get_distance(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Progress gets the current progress of self.
//
// The function returns the following values:
//
//   - gdouble: current progress, unitless.
//
func (self *Swipeable) Progress() float64 {
	var _arg0 *C.AdwSwipeable // out
	var _cret C.double        // in

	_arg0 = (*C.AdwSwipeable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_swipeable_get_progress(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// SnapPoints gets the snap points of self.
//
// Each snap point represents a progress value that is considered acceptable to
// end the swipe on.
//
// The function returns the following values:
//
//   - gdoubles: snap points.
//
func (self *Swipeable) SnapPoints() []float64 {
	var _arg0 *C.AdwSwipeable // out
	var _cret *C.double       // in
	var _arg1 C.int           // in

	_arg0 = (*C.AdwSwipeable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_swipeable_get_snap_points(_arg0, &_arg1)
	runtime.KeepAlive(self)

	var _gdoubles []float64 // out

	defer C.free(unsafe.Pointer(_cret))
	_gdoubles = make([]float64, _arg1)
	copy(_gdoubles, unsafe.Slice((*float64)(unsafe.Pointer(_cret)), _arg1))

	return _gdoubles
}

// SwipeArea gets the area self can start a swipe from for the given direction
// and gesture type.
//
// This can be used to restrict swipes to only be possible from a certain area,
// for example, to only allow edge swipes, or to have a draggable element and
// ignore swipes elsewhere.
//
// If not implemented, the default implementation returns the allocation of
// self, allowing swipes from anywhere.
//
// The function takes the following parameters:
//
//   - navigationDirection: direction of the swipe.
//   - isDrag: whether the swipe is caused by a dragging gesture.
//
// The function returns the following values:
//
//   - rect: pointer to a rectangle to store the swipe area.
//
func (self *Swipeable) SwipeArea(navigationDirection NavigationDirection, isDrag bool) *gdk.Rectangle {
	var _arg0 *C.AdwSwipeable          // out
	var _arg1 C.AdwNavigationDirection // out
	var _arg2 C.gboolean               // out
	var _arg3 C.GdkRectangle           // in

	_arg0 = (*C.AdwSwipeable)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwNavigationDirection(navigationDirection)
	if isDrag {
		_arg2 = C.TRUE
	}

	C.adw_swipeable_get_swipe_area(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(navigationDirection)
	runtime.KeepAlive(isDrag)

	var _rect *gdk.Rectangle // out

	_rect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _rect
}

// cancelProgress gets the progress self will snap back to after the gesture is
// canceled.
//
// The function returns the following values:
//
//   - gdouble: cancel progress, unitless.
//
func (self *Swipeable) cancelProgress() float64 {
	gclass := (*C.AdwSwipeableInterface)(coreglib.PeekParentClass(self))
	fnarg := gclass.get_cancel_progress

	var _arg0 *C.AdwSwipeable // out
	var _cret C.double        // in

	_arg0 = (*C.AdwSwipeable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C._gotk4_adw1_Swipeable_virtual_get_cancel_progress(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Distance gets the swipe distance of self.
//
// This corresponds to how many pixels 1 unit represents.
//
// The function returns the following values:
//
//   - gdouble: swipe distance in pixels.
//
func (self *Swipeable) distance() float64 {
	gclass := (*C.AdwSwipeableInterface)(coreglib.PeekParentClass(self))
	fnarg := gclass.get_distance

	var _arg0 *C.AdwSwipeable // out
	var _cret C.double        // in

	_arg0 = (*C.AdwSwipeable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C._gotk4_adw1_Swipeable_virtual_get_distance(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Progress gets the current progress of self.
//
// The function returns the following values:
//
//   - gdouble: current progress, unitless.
//
func (self *Swipeable) progress() float64 {
	gclass := (*C.AdwSwipeableInterface)(coreglib.PeekParentClass(self))
	fnarg := gclass.get_progress

	var _arg0 *C.AdwSwipeable // out
	var _cret C.double        // in

	_arg0 = (*C.AdwSwipeable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C._gotk4_adw1_Swipeable_virtual_get_progress(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// snapPoints gets the snap points of self.
//
// Each snap point represents a progress value that is considered acceptable to
// end the swipe on.
//
// The function returns the following values:
//
//   - gdoubles: snap points.
//
func (self *Swipeable) snapPoints() []float64 {
	gclass := (*C.AdwSwipeableInterface)(coreglib.PeekParentClass(self))
	fnarg := gclass.get_snap_points

	var _arg0 *C.AdwSwipeable // out
	var _cret *C.double       // in
	var _arg1 C.int           // in

	_arg0 = (*C.AdwSwipeable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C._gotk4_adw1_Swipeable_virtual_get_snap_points(unsafe.Pointer(fnarg), _arg0, &_arg1)
	runtime.KeepAlive(self)

	var _gdoubles []float64 // out

	defer C.free(unsafe.Pointer(_cret))
	_gdoubles = make([]float64, _arg1)
	copy(_gdoubles, unsafe.Slice((*float64)(unsafe.Pointer(_cret)), _arg1))

	return _gdoubles
}

// swipeArea gets the area self can start a swipe from for the given direction
// and gesture type.
//
// This can be used to restrict swipes to only be possible from a certain area,
// for example, to only allow edge swipes, or to have a draggable element and
// ignore swipes elsewhere.
//
// If not implemented, the default implementation returns the allocation of
// self, allowing swipes from anywhere.
//
// The function takes the following parameters:
//
//   - navigationDirection: direction of the swipe.
//   - isDrag: whether the swipe is caused by a dragging gesture.
//
// The function returns the following values:
//
//   - rect: pointer to a rectangle to store the swipe area.
//
func (self *Swipeable) swipeArea(navigationDirection NavigationDirection, isDrag bool) *gdk.Rectangle {
	gclass := (*C.AdwSwipeableInterface)(coreglib.PeekParentClass(self))
	fnarg := gclass.get_swipe_area

	var _arg0 *C.AdwSwipeable          // out
	var _arg1 C.AdwNavigationDirection // out
	var _arg2 C.gboolean               // out
	var _arg3 C.GdkRectangle           // in

	_arg0 = (*C.AdwSwipeable)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.AdwNavigationDirection(navigationDirection)
	if isDrag {
		_arg2 = C.TRUE
	}

	C._gotk4_adw1_Swipeable_virtual_get_swipe_area(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(navigationDirection)
	runtime.KeepAlive(isDrag)

	var _rect *gdk.Rectangle // out

	_rect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _rect
}

// SwipeableInterface: interface for swipeable widgets.
//
// An instance of this type is always passed by reference.
type SwipeableInterface struct {
	*swipeableInterface
}

// swipeableInterface is the struct that's finalized.
type swipeableInterface struct {
	native *C.AdwSwipeableInterface
}
