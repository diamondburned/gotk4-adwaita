// Code generated by girgen. DO NOT EDIT.

package adw

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/gtk/v4"
)

// #include <stdlib.h>
// #include <adwaita.h>
// #include <glib-object.h>
import "C"

// GType values.
var (
	GTypeTabPage = coreglib.Type(C.adw_tab_page_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeTabPage, F: marshalTabPage},
	})
}

// TabPageOverrides contains methods that are overridable.
type TabPageOverrides struct {
}

func defaultTabPageOverrides(v *TabPage) TabPageOverrides {
	return TabPageOverrides{}
}

// TabPage: auxiliary class used by tabview.
type TabPage struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TabPage)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TabPage, *TabPageClass, TabPageOverrides](
		GTypeTabPage,
		initTabPageClass,
		wrapTabPage,
		defaultTabPageOverrides,
	)
}

func initTabPageClass(gclass unsafe.Pointer, overrides TabPageOverrides, classInitFunc func(*TabPageClass)) {
	if classInitFunc != nil {
		class := (*TabPageClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTabPage(obj *coreglib.Object) *TabPage {
	return &TabPage{
		Object: obj,
	}
}

func marshalTabPage(p uintptr) (interface{}, error) {
	return wrapTabPage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Child gets the child of self.
//
// The function returns the following values:
//
//   - widget: child of self.
//
func (self *TabPage) Child() gtk.Widgetter {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget gtk.Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gtk.Widgetter)
			return ok
		})
		rv, ok := casted.(gtk.Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// Icon gets the icon of self.
//
// The function returns the following values:
//
//   - icon (optional) of self.
//
func (self *TabPage) Icon() *gio.Icon {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.GIcon      // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_icon(_arg0)
	runtime.KeepAlive(self)

	var _icon *gio.Icon // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_icon = &gio.Icon{
				Object: obj,
			}
		}
	}

	return _icon
}

// IndicatorActivatable gets whether the indicator of self is activatable.
//
// The function returns the following values:
//
//   - ok: whether the indicator is activatable.
//
func (self *TabPage) IndicatorActivatable() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_indicator_activatable(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IndicatorIcon gets the indicator icon of self.
//
// The function returns the following values:
//
//   - icon (optional): indicator icon of self.
//
func (self *TabPage) IndicatorIcon() *gio.Icon {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.GIcon      // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_indicator_icon(_arg0)
	runtime.KeepAlive(self)

	var _icon *gio.Icon // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_icon = &gio.Icon{
				Object: obj,
			}
		}
	}

	return _icon
}

// IndicatorTooltip gets the tooltip of the indicator icon of self.
//
// The function returns the following values:
//
//   - utf8: indicator tooltip of self.
//
func (self *TabPage) IndicatorTooltip() string {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.char       // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_indicator_tooltip(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Loading gets whether self is loading.
//
// The function returns the following values:
//
//   - ok: whether self is loading.
//
func (self *TabPage) Loading() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_loading(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NeedsAttention gets whether self needs attention.
//
// The function returns the following values:
//
//   - ok: whether self needs attention.
//
func (self *TabPage) NeedsAttention() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_needs_attention(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Parent gets the parent page of self.
//
// See tabview.AddPage and tabview.ClosePage.
//
// The function returns the following values:
//
//   - tabPage (optional): parent page.
//
func (self *TabPage) Parent() *TabPage {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.AdwTabPage // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_parent(_arg0)
	runtime.KeepAlive(self)

	var _tabPage *TabPage // out

	if _cret != nil {
		_tabPage = wrapTabPage(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _tabPage
}

// Pinned gets whether self is pinned.
//
// See tabview.SetPagePinned.
//
// The function returns the following values:
//
//   - ok: whether self is pinned.
//
func (self *TabPage) Pinned() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_pinned(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Selected gets whether self is selected.
//
// The function returns the following values:
//
//   - ok: whether self is selected.
//
func (self *TabPage) Selected() bool {
	var _arg0 *C.AdwTabPage // out
	var _cret C.gboolean    // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_selected(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title gets the title of self.
//
// The function returns the following values:
//
//   - utf8: title of self.
//
func (self *TabPage) Title() string {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.char       // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_title(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Tooltip gets the tooltip of self.
//
// The function returns the following values:
//
//   - utf8 (optional): tooltip of self.
//
func (self *TabPage) Tooltip() string {
	var _arg0 *C.AdwTabPage // out
	var _cret *C.char       // in

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.adw_tab_page_get_tooltip(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SetIcon sets the icon of self.
//
// tabbar displays the icon next to the title.
//
// It will not show the icon if tabpage:loading is set to TRUE, or if the page
// is pinned and [propertyTabPage:indicator-icon] is set.
//
// The function takes the following parameters:
//
//   - icon (optional) of self.
//
func (self *TabPage) SetIcon(icon gio.Iconner) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.GIcon      // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if icon != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	}

	C.adw_tab_page_set_icon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(icon)
}

// SetIndicatorActivatable sets whether the indicator of self is activatable.
//
// If set to TRUE, tabview::indicator-activated will be emitted when the
// indicator icon is clicked.
//
// If tabpage:indicator-icon is not set, does nothing.
//
// The function takes the following parameters:
//
//   - activatable: whether the indicator is activatable.
//
func (self *TabPage) SetIndicatorActivatable(activatable bool) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if activatable {
		_arg1 = C.TRUE
	}

	C.adw_tab_page_set_indicator_activatable(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(activatable)
}

// SetIndicatorIcon sets the indicator icon of self.
//
// A common use case is an audio or camera indicator in a web browser.
//
// tabbar will show it at the beginning of the tab, alongside icon representing
// tabpage:icon or loading spinner.
//
// If the page is pinned, the indicator will be shown instead of icon or
// spinner.
//
// tabpage:indicator-tooltip can be used to set the tooltip on the indicator
// icon.
//
// If tabpage:indicator-activatable is set to TRUE, the indicator icon can act
// as a button.
//
// The function takes the following parameters:
//
//   - indicatorIcon (optional): indicator icon of self.
//
func (self *TabPage) SetIndicatorIcon(indicatorIcon gio.Iconner) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.GIcon      // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if indicatorIcon != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(indicatorIcon).Native()))
	}

	C.adw_tab_page_set_indicator_icon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(indicatorIcon)
}

// SetIndicatorTooltip sets the tooltip of the indicator icon of self.
//
// The tooltip can be marked up with the Pango text markup language.
//
// See tabpage:indicator-icon.
//
// The function takes the following parameters:
//
//   - tooltip: indicator tooltip of self.
//
func (self *TabPage) SetIndicatorTooltip(tooltip string) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.char       // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(tooltip)))
	defer C.free(unsafe.Pointer(_arg1))

	C.adw_tab_page_set_indicator_tooltip(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(tooltip)
}

// SetLoading sets whether self is loading.
//
// If set to TRUE, tabbar will display a spinner in place of icon.
//
// If the page is pinned and tabpage:indicator-icon is set, the loading status
// will not be visible.
//
// The function takes the following parameters:
//
//   - loading: whether self is loading.
//
func (self *TabPage) SetLoading(loading bool) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if loading {
		_arg1 = C.TRUE
	}

	C.adw_tab_page_set_loading(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(loading)
}

// SetNeedsAttention sets whether self needs attention.
//
// tabbar will display a line under the tab representing the page if set to
// TRUE. If the tab is not visible, the corresponding edge of the tab bar will
// be highlighted.
//
// The function takes the following parameters:
//
//   - needsAttention: whether self needs attention.
//
func (self *TabPage) SetNeedsAttention(needsAttention bool) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if needsAttention {
		_arg1 = C.TRUE
	}

	C.adw_tab_page_set_needs_attention(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(needsAttention)
}

// SetTitle: tabbar will display it in the center of the tab unless it's pinned,
// and will use it as a tooltip unless tabpage:tooltip is set.
//
// Sets the title of self.
//
// The function takes the following parameters:
//
//   - title of self.
//
func (self *TabPage) SetTitle(title string) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.char       // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.adw_tab_page_set_title(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(title)
}

// SetTooltip sets the tooltip of self.
//
// The tooltip can be marked up with the Pango text markup language.
//
// If not set, tabbar will use tabpage:title as a tooltip instead.
//
// The function takes the following parameters:
//
//   - tooltip of self.
//
func (self *TabPage) SetTooltip(tooltip string) {
	var _arg0 *C.AdwTabPage // out
	var _arg1 *C.char       // out

	_arg0 = (*C.AdwTabPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(tooltip)))
	defer C.free(unsafe.Pointer(_arg1))

	C.adw_tab_page_set_tooltip(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(tooltip)
}

// TabPageClass: instance of this type is always passed by reference.
type TabPageClass struct {
	*tabPageClass
}

// tabPageClass is the struct that's finalized.
type tabPageClass struct {
	native *C.AdwTabPageClass
}

// TabViewClass: instance of this type is always passed by reference.
type TabViewClass struct {
	*tabViewClass
}

// tabViewClass is the struct that's finalized.
type tabViewClass struct {
	native *C.AdwTabViewClass
}

func (t *TabViewClass) ParentClass() *gtk.WidgetClass {
	valptr := &t.native.parent_class
	var _v *gtk.WidgetClass // out
	_v = (*gtk.WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}
